# This file was automatically generated by SWIG (http://www.swig.org).
# Version 4.0.1
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.


from typing import Union



from sys import version_info as _swig_python_version_info
if _swig_python_version_info < (2, 7, 0):
    raise RuntimeError("Python 2.7 or later required")

# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _monopod
else:
    import _monopod

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "thisown":
            self.this.own(value)
        elif name == "this":
            set(self, name, value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)



def ToMonopodWorld(base):
    return _monopod.ToMonopodWorld(base)

def ToMonopodModel(base):
    return _monopod.ToMonopodModel(base)

def ToMonopodJoint(base):
    return _monopod.ToMonopodJoint(base)
class SwigPyIterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _monopod.delete_SwigPyIterator

    def value(self):
        return _monopod.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _monopod.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _monopod.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _monopod.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _monopod.SwigPyIterator_equal(self, x)

    def copy(self):
        return _monopod.SwigPyIterator_copy(self)

    def next(self):
        return _monopod.SwigPyIterator_next(self)

    def __next__(self):
        return _monopod.SwigPyIterator___next__(self)

    def previous(self):
        return _monopod.SwigPyIterator_previous(self)

    def advance(self, n):
        return _monopod.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _monopod.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _monopod.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _monopod.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _monopod.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _monopod.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _monopod.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self

# Register SwigPyIterator in _monopod:
_monopod.SwigPyIterator_swigregister(SwigPyIterator)

SHARED_PTR_DISOWN = _monopod.SHARED_PTR_DISOWN
class VectorOfModels(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _monopod.VectorOfModels_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _monopod.VectorOfModels___nonzero__(self)

    def __bool__(self):
        return _monopod.VectorOfModels___bool__(self)

    def __len__(self):
        return _monopod.VectorOfModels___len__(self)

    def __getslice__(self, i, j):
        return _monopod.VectorOfModels___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _monopod.VectorOfModels___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _monopod.VectorOfModels___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _monopod.VectorOfModels___delitem__(self, *args)

    def __getitem__(self, *args):
        return _monopod.VectorOfModels___getitem__(self, *args)

    def __setitem__(self, *args):
        return _monopod.VectorOfModels___setitem__(self, *args)

    def pop(self):
        return _monopod.VectorOfModels_pop(self)

    def append(self, x):
        return _monopod.VectorOfModels_append(self, x)

    def empty(self):
        return _monopod.VectorOfModels_empty(self)

    def size(self):
        return _monopod.VectorOfModels_size(self)

    def swap(self, v):
        return _monopod.VectorOfModels_swap(self, v)

    def begin(self):
        return _monopod.VectorOfModels_begin(self)

    def end(self):
        return _monopod.VectorOfModels_end(self)

    def rbegin(self):
        return _monopod.VectorOfModels_rbegin(self)

    def rend(self):
        return _monopod.VectorOfModels_rend(self)

    def clear(self):
        return _monopod.VectorOfModels_clear(self)

    def get_allocator(self):
        return _monopod.VectorOfModels_get_allocator(self)

    def pop_back(self):
        return _monopod.VectorOfModels_pop_back(self)

    def erase(self, *args):
        return _monopod.VectorOfModels_erase(self, *args)

    def __init__(self, *args):
        _monopod.VectorOfModels_swiginit(self, _monopod.new_VectorOfModels(*args))

    def push_back(self, x):
        return _monopod.VectorOfModels_push_back(self, x)

    def front(self):
        return _monopod.VectorOfModels_front(self)

    def back(self):
        return _monopod.VectorOfModels_back(self)

    def assign(self, n, x):
        return _monopod.VectorOfModels_assign(self, n, x)

    def resize(self, *args):
        return _monopod.VectorOfModels_resize(self, *args)

    def insert(self, *args):
        return _monopod.VectorOfModels_insert(self, *args)

    def reserve(self, n):
        return _monopod.VectorOfModels_reserve(self, n)

    def capacity(self):
        return _monopod.VectorOfModels_capacity(self)
    __swig_destroy__ = _monopod.delete_VectorOfModels

# Register VectorOfModels in _monopod:
_monopod.VectorOfModels_swigregister(VectorOfModels)

import scenario.bindings.core
class Joint(scenario.bindings.core.Joint):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _monopod.Joint_swiginit(self, _monopod.new_Joint())
    __swig_destroy__ = _monopod.delete_Joint

    def initialize(self, name_index_pair, monopod_sdk):
        return _monopod.Joint_initialize(self, name_index_pair, monopod_sdk)

    def valid(self):
        r"""
        Check if the joint is valid.

        :rtype: boolean
        :return: True if the model is valid, false otherwise.
        """
        return _monopod.Joint_valid(self)

    def dofs(self):
        r"""
        Get the number of degrees of freedom of the joint.

        :rtype: int
        :return: The number of DOFs of the joint.
        """
        return _monopod.Joint_dofs(self)

    def name(self, scoped=False):
        r"""
        Get the name of the joint.

        :type scoped: boolean
        :param scoped: If true, the scoped name of the joint is returned.
        :rtype: string
        :return: The name of the joint.
        """
        return _monopod.Joint_name(self, scoped)

    def type(self):
        r"""
        Get the type of the joint.

        :rtype: int
        :return: The type of the joint.
        """
        return _monopod.Joint_type(self)

    def set_control_mode(self, mode):
        r"""
        Set the joint control mode.

        :type mode: int
        :param mode: The desired control mode.
        :rtype: boolean
        :return: True for success, false otherwise.
        """
        return _monopod.Joint_set_control_mode(self, mode)

    def control_mode(self):
        r"""
        get the joint control mode.

        :rtype: int
        :return: the joint control mode
        """
        return _monopod.Joint_control_mode(self)

    def pid(self):
        r"""
        Get the PID parameters of the joint.

        If no PID parameters have been set, the default parameters are
        returned.

        :rtype: :py:class:`PID`
        :return: The joint PID parameters.
        """
        return _monopod.Joint_pid(self)

    def set_pid(self, pid):
        r"""
        Set the PID parameters of the joint.

        :type pid: :py:class:`PID`
        :param pid: The desired PID parameters.
        :rtype: boolean
        :return: True for success, false otherwise.
        """
        return _monopod.Joint_set_pid(self, pid)

    def joint_max_generalized_force(self):
        r"""
        Get the maximum generalized force that could be applied to the joint.

        :rtype: Tuple[float]
        :return: The maximum generalized force of the joint.
        """
        return _monopod.Joint_joint_max_generalized_force(self)

    def set_joint_max_generalized_force(self, max_force):
        r"""
        Set the maximum generalized force that can be applied to the joint.

        This limit can be used to clip the force applied by joint
        controllers.

        :type maxForce: Tuple[float]
        :param maxForce: A vector with the maximum generalized forces of the
            joint DOFs.
        :rtype: boolean
        :return: True for success, false otherwise.
        """
        return _monopod.Joint_set_joint_max_generalized_force(self, max_force)

    def joint_position(self):
        r"""
        Get the position of the joint.

        :rtype: Tuple[float]
        :return: The position of the joint.
        """
        return _monopod.Joint_joint_position(self)

    def joint_velocity(self):
        r"""
        Get the velocity of the joint.

        :rtype: Tuple[float]
        :return: The velocity of the joint.
        """
        return _monopod.Joint_joint_velocity(self)

    def joint_acceleration(self):
        r"""
        Get the acceleration of the joint.

        :rtype: Tuple[float]
        :return: The acceleration of the joint.
        """
        return _monopod.Joint_joint_acceleration(self)

    def set_joint_generalized_force_target(self, force):
        r"""
        Set the generalized force target of the joint.

        Note that if there's friction or other loss components, the real
        joint force will differ.

        :type force: Tuple[float]
        :param force: A vector with the generalized force targets of the joint
            DOFs.
        :rtype: boolean
        :return: True for success, false otherwise.
        """
        return _monopod.Joint_set_joint_generalized_force_target(self, force)

    def joint_generalized_force_target(self):
        r"""
        Get the active generalized force target.

        :rtype: Tuple[float]
        :return: The generalized force target of the joint.
        """
        return _monopod.Joint_joint_generalized_force_target(self)

    def joint_position_limit(self):
        r"""
        Get the position limits of the joint.

        :rtype: :py:class:`JointLimit`
        :return: The position limits of the joint.
        """
        return _monopod.Joint_joint_position_limit(self)

    def joint_velocity_limit(self):
        r"""
        Get the velocity limits of the joint.

        :rtype: :py:class:`JointLimit`
        :return: The velocity limits of the joint.
        """
        return _monopod.Joint_joint_velocity_limit(self)

    def joint_acceleration_limit(self):
        r"""
        Get the acceleration limits of the joint.

        :rtype: :py:class:`JointLimit`
        :return: The acceleration limits of the joint.
        """
        return _monopod.Joint_joint_acceleration_limit(self)

    def set_joint_position_limit(self, max_position, min_position):
        r"""
        Set the maximum position of the joint.

        This limit can be used to set safety limits on the joint position.
        when violated the Robot will enter into a safe mode. disabling the robot
        until it is reset or restart.

        :type maxPosition: float
        :param maxPosition: maximum position of the joint DOFs.
        :type minPosition: float
        :param minPosition: minimum position of the joint DOFs.
        :rtype: boolean
        :return: True for success, false otherwise.
        """
        return _monopod.Joint_set_joint_position_limit(self, max_position, min_position)

    def set_joint_velocity_limit(self, max_velocity, min_velocity):
        r"""
        Set the maximum velocity of the joint.

        This limit can be used to set safety limits on the joint velocity.
        when violated the Robot will enter into a safe mode. disabling the robot
        until it is reset or restart.

        :type maxVelocity: float
        :param maxVelocity: maximum velocity of the joint DOFs.
        :type minVelocity: float
        :param minVelocity: minimum position of the joint DOFs.
        :rtype: boolean
        :return: True for success, false otherwise.
        """
        return _monopod.Joint_set_joint_velocity_limit(self, max_velocity, min_velocity)

    def set_joint_acceleration_limit(self, max_acceleration, min_acceleration):
        r"""
        Set the maximum acceleration of the joint.

        This limit can be used to set safety limits on the joint acceleration.
        when violated the Robot will enter into a safe mode. disabling the robot
        until it is reset or restart.

        :type maxAcceleration: float
        :param maxAcceleration: maximum acceleration of the joint DOFs.
        :type minAcceleration: float
        :param minAcceleration: minimum acceleration of the joint DOFs.
        :rtype: boolean
        :return: True for success, false otherwise.
        """
        return _monopod.Joint_set_joint_acceleration_limit(self, max_acceleration, min_acceleration)

# Register Joint in _monopod:
_monopod.Joint_swigregister(Joint)

class Model(scenario.bindings.core.Model):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _monopod.Model_swiginit(self, _monopod.new_Model())
    __swig_destroy__ = _monopod.delete_Model

    def initialize(self, mode, dummy_mode):
        r"""
        Initialize can_bus connections to encoder board and motor board.

        :param monopod_mode: defines the task mode of the monopod. Can also specify
            individual boards.
        :type dummy_mode: boolean
        :param dummy_mode: if false the sdk will try to connect to the
            canbus connection otherwise it will just create a dummy board class which
            fakes the real robot.
        """
        return _monopod.Model_initialize(self, mode, dummy_mode)

    def calibrate(self, hip_home_offset_rad=0, knee_home_offset_rad=0):
        r"""
        Calibrate the Encoders.

        :type hip_home_offset_rad: float
        :param hip_home_offset_rad: hip offset from found encoder index 0 (rad)
        :type knee_home_offset_rad: float
        :param knee_home_offset_rad: knee offset from found encoder index 0 (rad)
        """
        return _monopod.Model_calibrate(self, hip_home_offset_rad, knee_home_offset_rad)

    def reset(self):
        r"""
        If the joint module is not valid (safemode after limit reached) the
        joint will be reset into a valid state. This means the joint must be set
        back into the valid state first otherwise it will trigger the limits again.
        """
        return _monopod.Model_reset(self)

    def print_status(self):
        r"""print status messages of robot."""
        return _monopod.Model_print_status(self)

    def valid(self):
        r"""
        Check if the model is valid.

        :rtype: boolean
        :return: True if the model is valid, false otherwise.
        """
        return _monopod.Model_valid(self)

    def name(self):
        r"""
        Get the name of the model.

        :rtype: string
        :return: The name of the model.
        """
        return _monopod.Model_name(self)

    def dofs(self, *args):
        r"""
        Get the joints DOF

        :type jointNames: Tuple[string]
        :param jointNames: Optional vector of considered joints that also
            defines the joint serialization. By default, ``Model::jointNames`` is
            used.
        :rtype: int
        :return: The sum of serialization of joint DOFs. The sum is the number of
            DoFs of all the considered joints.
        """
        return _monopod.Model_dofs(self, *args)

    def get_joint(self, joint_name):
        r"""
        Get a joint belonging to the model.

        :type jointName: string
        :param jointName: The name of the joint.
        :raises: std::runtime_error if the joint does not exist.
        :rtype: :py:class:`Joint`
        :return: The desired joint.
        """
        return _monopod.Model_get_joint(self, joint_name)

    def joint_names(self, scoped=False):
        r"""
        Get the name of all the model's joints.

        :type scoped: boolean
        :param scoped: Scope the joint names with the model name,
            (e.g. ``mymodel::joint1``).
        :rtype: Tuple[string]
        :return: The list of joint names.
        """
        return _monopod.Model_joint_names(self, scoped)

    def joint_positions(self, *args):
        r"""
        Get the joint positions.

        :type jointNames: Tuple[string]
        :param jointNames: Optional vector of considered joints that also
            defines the joint serialization. By default, ``Model::jointNames`` is
            used.
        :rtype: Tuple[float]
        :return: The serialization of joint positions. The vector has as many
            elements as DoFs of the considered joints.
        """
        return _monopod.Model_joint_positions(self, *args)

    def joint_velocities(self, *args):
        r"""
        Get the joint velocities.

        :type jointNames: Tuple[string]
        :param jointNames: Optional vector of considered joints that also
            defines the joint serialization. By default, ``Model::jointNames`` is
            used.
        :rtype: Tuple[float]
        :return: The serialization of joint velocities. The vector has as many
            elements as DoFs of the considered joints.
        """
        return _monopod.Model_joint_velocities(self, *args)

    def joint_accelerations(self, *args):
        r"""
        Get the joint accelerations.

        :type jointNames: Tuple[string]
        :param jointNames: Optional vector of considered joints that also
            defines the joint serialization. By default, ``Model::jointNames`` is
            used.
        :rtype: Tuple[float]
        :return: The serialization of joint accelerations. The vector has as many
            elements as DoFs of the considered joints.
        """
        return _monopod.Model_joint_accelerations(self, *args)

    def set_joint_control_mode(self, *args):
        r"""
        Set the control mode of model joints.

        :type mode: int
        :param mode: The desired joint control mode.
        :type jointNames: Tuple[string]
        :param jointNames: Optional vector of considered joints that also
            defines the joint serialization. By default, ``Model::jointNames`` is
            used.
        :rtype: boolean
        :return: True for success, false otherwise.
        """
        return _monopod.Model_set_joint_control_mode(self, *args)

    def joints(self, *args):
        r"""
        Get the joints of the model.

        :type jointNames: Tuple[string]
        :param jointNames: Optional vector of considered joints. By default,
            ``Model::jointNames`` is used.
        :rtype: Tuple[Joint]
        :return: A vector of pointers to the joint objects.
        """
        return _monopod.Model_joints(self, *args)

    def set_joint_generalized_force_targets(self, *args):
        r"""
        Set the generalized force targets of the joints.

        :type forces: Tuple[float]
        :param forces: The vector with the joint generalized force targets. It
            must have as many elements as the considered joint DoFs.
        :type jointNames: Tuple[string]
        :param jointNames: Optional vector of considered joints. By default,
            ``Model::jointNames`` is used.
        :rtype: boolean
        :return: True for success, false otherwise.
        """
        return _monopod.Model_set_joint_generalized_force_targets(self, *args)

    def joint_generalized_force_targets(self, *args):
        r"""
        Get the generalized force targets of the joints.

        :type jointNames: Tuple[string]
        :param jointNames: Optional vector of considered joints. By default,
            ``Model::jointNames`` is used.
        :rtype: Tuple[float]
        :return: The generalized force targets of the joints.
        """
        return _monopod.Model_joint_generalized_force_targets(self, *args)

    def set_controller_period(self, period):
        return _monopod.Model_set_controller_period(self, period)

# Register Model in _monopod:
_monopod.Model_swigregister(Model)

class World(scenario.bindings.core.World):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _monopod.World_swiginit(self, _monopod.new_World())
    __swig_destroy__ = _monopod.delete_World

    def initialize(self, mode, dummy_mode=False):
        r"""
        Initialize can_bus connections to encoder board and motor board.

        :param monopod_mode: defines the task mode of the monopod. Can also specify
            individual boards.
        :type dummy_mode: boolean
        :param dummy_mode: if false the sdk will try to connect to the
            canbus connection otherwise it will just create a dummy board class which
            fakes the real robot.
        """
        return _monopod.World_initialize(self, mode, dummy_mode)

    def valid(self):
        r"""
        Check if the world is valid.

        :rtype: boolean
        :return: True if the world is valid, false otherwise.
        """
        return _monopod.World_valid(self)

    def name(self):
        r"""
        Get the name of the world.

        :rtype: string
        :return: The name of the world.
        """
        return _monopod.World_name(self)

    def model_names(self):
        r"""
        Get the name of the models that are part of the world.

        :rtype: Tuple[string]
        :return: The list of model names.
        """
        return _monopod.World_model_names(self)

    def get_model(self, model_name):
        r"""
        Get a model part of the world.

        :type modelName: string
        :param modelName: The name of the model to get.
        :rtype: :py:class:`Model`
        :return: The model if it is part of the world, ``nullptr`` otherwise.
        """
        return _monopod.World_get_model(self, model_name)

    def models(self, *args):
        r"""
        Get the models of the world.

        :type modelNames: Tuple[string]
        :param modelNames: Optional vector of considered models. By default,
            ``World::modelNames`` is used.
        :rtype: std::vector< scenario::core::ModelPtr,std::allocator< scenario::core::ModelPtr > >
        :return: A vector of pointers to the model objects.
        """
        return _monopod.World_models(self, *args)

# Register World in _monopod:
_monopod.World_swigregister(World)

Mode_free = _monopod.Mode_free
r"""Complete free boom connector (5 joints total)"""
Mode_fixed_connector = _monopod.Mode_fixed_connector
r"""Fixed boom connector (4 joints total)"""
Mode_fixed = _monopod.Mode_fixed
r"""Fixed boom connector and planrizer yaw (3 joints total)"""
Mode_motor_board = _monopod.Mode_motor_board
r"""motor board"""
Mode_encoder_board1 = _monopod.Mode_encoder_board1
r"""encoder board 1"""
Mode_encoder_board2 = _monopod.Mode_encoder_board2
r"""encoder board 2"""


