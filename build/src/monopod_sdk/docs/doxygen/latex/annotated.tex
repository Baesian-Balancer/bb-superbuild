\doxysection{Class List}
Here are the classes, structs, unions and interfaces with brief descriptions\+:\begin{DoxyCompactList}
\item\contentsline{section}{\mbox{\hyperlink{classmonopod__drivers_1_1BoardStatus}{monopod\+\_\+drivers\+::\+Board\+Status}} \\*This class represent a 8 bits message that describe the state (enable/disabled) of the card and the two motors or that of the car and 2 encoders }{\pageref{classmonopod__drivers_1_1BoardStatus}}{}
\item\contentsline{section}{\mbox{\hyperlink{classmonopod__drivers_1_1CanBus}{monopod\+\_\+drivers\+::\+Can\+Bus}} \\*\mbox{\hyperlink{classmonopod__drivers_1_1CanBus}{Can\+Bus}} is the implementation of the \mbox{\hyperlink{classmonopod__drivers_1_1CanBusInterface}{Can\+Bus\+Interface}} }{\pageref{classmonopod__drivers_1_1CanBus}}{}
\item\contentsline{section}{\mbox{\hyperlink{classmonopod__drivers_1_1CanBusConnection}{monopod\+\_\+drivers\+::\+Can\+Bus\+Connection}} \\*\mbox{\hyperlink{classmonopod__drivers_1_1CanBusConnection}{Can\+Bus\+Connection}} is a data structure that contains the hardware details for the connection between to can cards }{\pageref{classmonopod__drivers_1_1CanBusConnection}}{}
\item\contentsline{section}{\mbox{\hyperlink{classmonopod__drivers_1_1CanBusControlBoards}{monopod\+\_\+drivers\+::\+Can\+Bus\+Control\+Boards}} \\*This class \mbox{\hyperlink{classmonopod__drivers_1_1CanBusControlBoards}{Can\+Bus\+Control\+Boards}} implements a \mbox{\hyperlink{classmonopod__drivers_1_1ControlBoardsInterface}{Control\+Boards\+Interface}} specific to C\+AN networks }{\pageref{classmonopod__drivers_1_1CanBusControlBoards}}{}
\item\contentsline{section}{\mbox{\hyperlink{classmonopod__drivers_1_1CanBusFrame}{monopod\+\_\+drivers\+::\+Can\+Bus\+Frame}} \\*\mbox{\hyperlink{classmonopod__drivers_1_1CanBusFrame}{Can\+Bus\+Frame}} is a class that contains a fixed sized amount of data to be send or received via the can bus }{\pageref{classmonopod__drivers_1_1CanBusFrame}}{}
\item\contentsline{section}{\mbox{\hyperlink{classmonopod__drivers_1_1CanBusInterface}{monopod\+\_\+drivers\+::\+Can\+Bus\+Interface}} \\*\mbox{\hyperlink{classmonopod__drivers_1_1CanBusInterface}{Can\+Bus\+Interface}} is an abstract class that defines an A\+PI for the communication via Can bus }{\pageref{classmonopod__drivers_1_1CanBusInterface}}{}
\item\contentsline{section}{\mbox{\hyperlink{classmonopod__drivers_1_1ControlBoardsCommand}{monopod\+\_\+drivers\+::\+Control\+Boards\+Command}} \\*This \mbox{\hyperlink{classmonopod__drivers_1_1ControlBoardsCommand}{Control\+Boards\+Command}} class is a data structurs that defines a command to the \mbox{\hyperlink{classmonopod__drivers_1_1ControlBoardsInterface_ab1d667a531570d2c5782f0faf451e5a4}{monopod\+\_\+drivers\+::\+Control\+Boards\+Interface\+::\+Board\+Index}} boards }{\pageref{classmonopod__drivers_1_1ControlBoardsCommand}}{}
\item\contentsline{section}{\mbox{\hyperlink{classmonopod__drivers_1_1ControlBoardsInterface}{monopod\+\_\+drivers\+::\+Control\+Boards\+Interface}} \\*\mbox{\hyperlink{classmonopod__drivers_1_1ControlBoardsInterface}{Control\+Boards\+Interface}} declares an A\+PI to inacte with a Control\+Boards }{\pageref{classmonopod__drivers_1_1ControlBoardsInterface}}{}
\item\contentsline{section}{\mbox{\hyperlink{classmonopod__drivers_1_1DeviceInterface}{monopod\+\_\+drivers\+::\+Device\+Interface}} \\*This class exists purely for logical reasons, it does not in itself implement anything }{\pageref{classmonopod__drivers_1_1DeviceInterface}}{}
\item\contentsline{section}{\mbox{\hyperlink{classmonopod__drivers_1_1DummyControlBoards}{monopod\+\_\+drivers\+::\+Dummy\+Control\+Boards}} \\*This class \mbox{\hyperlink{classmonopod__drivers_1_1DummyControlBoards}{Dummy\+Control\+Boards}} implements a \mbox{\hyperlink{classmonopod__drivers_1_1ControlBoardsInterface}{Control\+Boards\+Interface}} specific to C\+AN networks }{\pageref{classmonopod__drivers_1_1DummyControlBoards}}{}
\item\contentsline{section}{\mbox{\hyperlink{classmonopod__drivers_1_1Encoder}{monopod\+\_\+drivers\+::\+Encoder}} \\*This class implements the \mbox{\hyperlink{classmonopod__drivers_1_1EncoderInterface}{Encoder\+Interface}} }{\pageref{classmonopod__drivers_1_1Encoder}}{}
\item\contentsline{section}{\mbox{\hyperlink{classmonopod__drivers_1_1EncoderInterface}{monopod\+\_\+drivers\+::\+Encoder\+Interface}} \\*This class declares an interface to the motor. It allows the user to access the sensors data as well as sending controls. The only control supported for now is the current }{\pageref{classmonopod__drivers_1_1EncoderInterface}}{}
\item\contentsline{section}{\mbox{\hyperlink{classmonopod__drivers_1_1EncoderJointModule}{monopod\+\_\+drivers\+::\+Encoder\+Joint\+Module}} \\*Containing the joint information. It is here to help converting the data from the encoder side to the joint side. It also allows the calibration of the joint position during initialization }{\pageref{classmonopod__drivers_1_1EncoderJointModule}}{}
\item\contentsline{section}{\mbox{\hyperlink{structmonopod__drivers_1_1HomingState}{monopod\+\_\+drivers\+::\+Homing\+State}} \\*State variables required for the homing }{\pageref{structmonopod__drivers_1_1HomingState}}{}
\item\contentsline{section}{\mbox{\hyperlink{structmonopod__drivers_1_1JointLimit}{monopod\+\_\+drivers\+::\+Joint\+Limit}} \\*Structure holding joint limits }{\pageref{structmonopod__drivers_1_1JointLimit}}{}
\item\contentsline{section}{\mbox{\hyperlink{classmonopod__drivers_1_1Leg}{monopod\+\_\+drivers\+::\+Leg}} \\*The leg class is the implementation of the Leg\+Interface. This is the decalartion and the definition of the class as it is very simple }{\pageref{classmonopod__drivers_1_1Leg}}{}
\item\contentsline{section}{\mbox{\hyperlink{classmonopod__drivers_1_1Monopod}{monopod\+\_\+drivers\+::\+Monopod}} \\*Drivers for open sim2real monopod. Interfaces with the monopod TI motors using monopod\+\_\+drivers\+::\+Blmc\+Joint\+Module. This class creates a real time control thread which reads and writes from a buffer exposed to the public api }{\pageref{classmonopod__drivers_1_1Monopod}}{}
\item\contentsline{section}{\mbox{\hyperlink{classmonopod__drivers_1_1Motor}{monopod\+\_\+drivers\+::\+Motor}} \\*This class implements the \mbox{\hyperlink{classmonopod__drivers_1_1MotorInterface}{Motor\+Interface}} }{\pageref{classmonopod__drivers_1_1Motor}}{}
\item\contentsline{section}{\mbox{\hyperlink{classmonopod__drivers_1_1MotorInterface}{monopod\+\_\+drivers\+::\+Motor\+Interface}} \\*This class declares an interface to the motor. It allows the user to access the sensors data as well as sending controls. The only control supported for now is the current }{\pageref{classmonopod__drivers_1_1MotorInterface}}{}
\item\contentsline{section}{\mbox{\hyperlink{classmonopod__drivers_1_1MotorJointModule}{monopod\+\_\+drivers\+::\+Motor\+Joint\+Module}} \\*Containing the joint information. It is here to help converting the data from the motor side to the joint side. It also allows the calibration of the joint position during initialization }{\pageref{classmonopod__drivers_1_1MotorJointModule}}{}
\item\contentsline{section}{\mbox{\hyperlink{structmonopod__drivers_1_1PID}{monopod\+\_\+drivers\+::\+P\+ID}} \\*Structure holding the \mbox{\hyperlink{structmonopod__drivers_1_1PID}{P\+ID}} values for the joint }{\pageref{structmonopod__drivers_1_1PID}}{}
\item\contentsline{section}{\mbox{\hyperlink{classmonopod__drivers_1_1Polynome}{monopod\+\_\+drivers\+::\+Polynome$<$ O\+R\+D\+E\+R $>$}} \\*Simple class that defines $ P(x) $ a polynome of order O\+R\+D\+ER. It provide simple methods to compute $ P(x) $, $ \frac{dP}{dx}(x) $, and $ \frac{dP^2}{dx^2}(x) $ }{\pageref{classmonopod__drivers_1_1Polynome}}{}
\item\contentsline{section}{\mbox{\hyperlink{classmonopod__drivers_1_1TimePolynome}{monopod\+\_\+drivers\+::\+Time\+Polynome$<$ O\+R\+D\+E\+R $>$}} \\*Simple class that defines $ P(t) $ a polynome of order O\+R\+D\+ER. With $ t $ being the time in any units. It provide simple methods to compute safely $ P(time) $, $ \frac{dP}{dt}(t) $, and $ \frac{dP^2}{dt^2}(t) $ }{\pageref{classmonopod__drivers_1_1TimePolynome}}{}
\end{DoxyCompactList}
